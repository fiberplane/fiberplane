// =========================================== //
// DO NOT MAKE MANUAL CHANGES TO THIS FILE     //
// This file is automatically generated.       //
//                                             //
// To regenerate, run `pnpm build:types`       //
// from the root repository of the repository. //
// =========================================== //

import { z } from "zod";

// TODO: Polyfill memoizeOne for now, seems like this breaks our TypeScript setup
// See: https://github.com/alexreardon/memoize-one/issues/267
// Couldn't get it to work reliably on both the CI and locally with custom module type definitions
function memoizeOne<T>(schema: T) {
  return schema;
}

export const AppStateSchema = memoizeOne(() =>
  z.object({ workspace: z.union([z.lazy(WorkspaceSchema), z.null()]) }),
);

export type AppState = z.infer<ReturnType<typeof AppStateSchema>>;

export const ClientMessageSchema = memoizeOne(() =>
  z.object({ type: z.literal("debug") }),
);

export type ClientMessage = z.infer<ReturnType<typeof ClientMessageSchema>>;

export const FpxConfigSchema = memoizeOne(() =>
  z.object({ listen_port: z.union([z.number().int(), z.null()]) }),
);

export type FpxConfig = z.infer<ReturnType<typeof FpxConfigSchema>>;

export const FpxConfigErrorSchema = memoizeOne(() =>
  z.union([
    z.literal("RootDirectoryNotFound"),
    z.object({ FileNotFound: z.string() }),
    z.object({
      InvalidFpxConfig: z.object({
        message: z.string(),
        span: z.union([z.lazy(Range_of_uintSchema), z.null()]),
      }),
    }),
  ]),
);

export type FpxConfigError = z.infer<ReturnType<typeof FpxConfigErrorSchema>>;

export const OpenWorkspaceErrorSchema = memoizeOne(() =>
  z.discriminatedUnion("type", [
    z.object({ path: z.string(), type: z.literal("ConfigFileMissing") }),
    z.object({ message: z.string(), type: z.literal("InvalidConfiguration") }),
  ]),
);

export type OpenWorkspaceError = z.infer<
  ReturnType<typeof OpenWorkspaceErrorSchema>
>;

export const Range_of_uintSchema = memoizeOne(() =>
  z.object({ end: z.number().int(), start: z.number().int() }),
);

export type Range_of_uint = z.infer<ReturnType<typeof Range_of_uintSchema>>;

export const ServerErrorSchema = memoizeOne(() =>
  z.object({ error: z.literal("invalidMessage") }),
);

export type ServerError = z.infer<ReturnType<typeof ServerErrorSchema>>;

export const ServerMessageSchema = memoizeOne(() =>
  z.discriminatedUnion("type", [
    z.object({ type: z.literal("ack") }),
    z.object({ details: z.lazy(ServerErrorSchema), type: z.literal("error") }),
    z.object({
      details: z.lazy(SpanAddedSchema),
      type: z.literal("spanAdded"),
    }),
  ]),
);

export type ServerMessage = z.infer<ReturnType<typeof ServerMessageSchema>>;

export const SpanAddedSchema = memoizeOne(() =>
  z.object({ newSpans: z.array(z.tuple([z.string(), z.string()])) }),
);

export type SpanAdded = z.infer<ReturnType<typeof SpanAddedSchema>>;

export const WorkspaceSchema = memoizeOne(() =>
  z.object({ api_port: z.number().int(), path: z.string() }),
);

export type Workspace = z.infer<ReturnType<typeof WorkspaceSchema>>;
