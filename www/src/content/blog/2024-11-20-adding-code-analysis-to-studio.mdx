---
title: "Smart as a WIP: How Studio Analyzes Hono Apps"
description: A quick look at how Hono api code is statically analyzed in Fiberplane Studio
slug: code-analysis
date: 2024-11-22
author: Jacco Flenter
tags:
  - typescript
  - static analysis
  - Hono
---

import { Aside, LinkCard } from "@astrojs/starlight/components";


**TL;DR:** We've implemented static code analysis into Fiberplane Studio to 
help developers better understand and debug their Hono APIs. 
This post explains how we went about analyzing TypeScript code to extract route information from Hono APIs.

***

When building APIs with [Hono](https://hono.dev), understanding how your routes interact with middleware, validation, and database schemas can become complex. 
We recently improved how Fiberplane Studio analyzes your source code to provide better insights into these relationships.

Right now, this powers our "[Generate Request](https://fiberplane.com/docs/features/generating-with-ai/)" feature, which uses LLMs to generate request data.
Going forward, we will add some of this code intelligence to make Studio feel even more like a powerful IDE for testing and debugging Hono APIs.

<center>
![Fiberplane Studio generate request parameters](@/assets/blog/2024-11-20-generate-request.jpg)
</center>

## Understanding the Goals

Our code analysis serves two primary purposes:
- Discover all routes in a Hono application
- Identify the supporting code (validation, schemas, middleware) associated with each route

The goal is to find all routes in a Hono application, 
and then for each route, we'd like to find out which code is actually used to handle a request. 
This way, we can provide an LLM with context around what the application accepts/uses (like database schema, zod validation schemas, etc).

The end result is similar to writing a specification for your API, without the immense amount of boilerplate and overhead of doing so from day 1.

## How `@fiberplane/source-analysis` works

All of our code analysis logic is open source and lives in a dedicated npm package:

<LinkCard
  title="@fiberplane/source-analysis"
  description="The package that powers the code analysis in Fiberplane Studio"
  href="https://www.npmjs.com/package/@fiberplane/source-analysis"
  icon="external"
  target="_blank"
  rel="noopener noreferrer"
/>

The first thing we needed to do is to find all routes in a Hono api.
After that, we needed to find out all the code that is associated with each route,
_including its middleware_.

We considered several strategies.
One approach was to specify the main entry of an application, find the Hono app in that file, and go through the source code from there. 
The downside to this is that the entry file would need to be specified (or found out by our code base).

An alternative approach, which we went with, is to analyze all source code 
and find any variables that are of the `Hono<` generic type. 
From there, we can apply some heuristics to determine the entry point/main app.

On a high level what needs to happen is as follows:
1. **Extract routes** — Go through all code and map all apps, routes, middleware and links between apps. Also keep track of what code is related to the app/route/middleware and keep track of what code that code might refer to (etc). This data is stored in the `ResourceManager`. 
2. **Analyze routes** — Once all code has been converted into our own data structure, we find the hono apps and see which one has the most routes/entries (and if routes refer to each other their value is added as well). The app with the highest number is treated as the entry point.
3. **Describe routes** — Create an intermediate result: `RoutesResult`, which contains:

    *  A reference to a dummy Hono app, which can be used to find out what code is executed for a given method/request.
    * `getFilesForHistory()` method that can be called to see all code that can be executed for a request to an endpoint.
    * `resetHistory()` method so you can reset the result to the initial state.

### The data structures used to extract routes

The `@fiberplane/source-analysis` package uses several key data structures to represent the elements of a Hono project. 
Understanding these data structures can be helpful if you want to work in this package.

#### `RouteTree`

The `RouteTree` type represents a reference to an `app` instance created with `new Hono()`.
It contains a list of `entries`, which includes information about any calls to the `app` that add routes (such as `app.get()`, `app.use()`, and `app.route()`).

```typescript
export type RouteTree = {
  id: RouteTreeId;
  type: "ROUTE_TREE";
  entries: RouteTreeEntry[];
  // other properties...
};
```

#### `RouteTreeEntry`

The `RouteTreeEntry` type represents an entry in a route tree. It can be one of the following types:

- `RouteEntry` — This represents a call to `app.get()`
- `RouteTreeReference` — This is the data structure for `app.route()`
- `MiddlewareEntry` — Represents calls to `app.use()`

```typescript
export type RouteTreeEntry = RouteEntry | RouteTreeReference | MiddlewareEntry;
```

#### Other data structures

In order to capture information about other code the packages uses two other data structures:

- `SourceReference` This is a reference to section of code (like a function, a constant, etc).  A source reference can refer to one or more `SourceReference` as well as one or more `ModuleReferences`
- A `ModuleReference` represents a link to another file/external package and is source code (part of) an import statement. 

All data structures (apart from `ModuleReference` can contain references to either modules or source references) . All resources are stored using their id in a `Map` in the ResourceManager. Although `ID`s are basically strings -which always start with the basic type like `ROUTE_TREE`, `SOURCE_REFERENCE`, etc - in typescript land they are made specific using [type tagging](https://medium.com/@KevinBGreene/surviving-the-typescript-ecosystem-branding-and-type-tagging-6cf6e516523d) (using type-fest). This way typescript is aware what kind of a resource is being returned when calling `ResourceManager.getResource`.

## Extracting the code for a route

After creating the resources based on the source code, the main entry endpoint is determined. That main entry point is then used in the `RoutesResult` to set up a separate Hono app. This hono app is never actually listening on a port but is used to send requests to.  The reconstructed app could be written out something like this:

``` ts
type HistoryId =
  | RouteEntryId
  | RouteTreeId
  | RouteTreeReferenceId
  | MiddlewareEntryId;
const history: Array<HistoryId> = [];

const routingApp = new Hono();
routingApp.use((_, next) => {
  // Append main RouteTreeId to history
  history.push("SOME_ROUTE_TREE_ID");
  return next();
});

routingApp.get("/", (c) => {
  // Append RouteEntryId to history
  history.push("SOME_ROUTE_ENTRY_ID");
  return c.text("Ok");
});

routingApp.get("/profile", () => {
  // Append  RouteEntryId to history
  history.push("SOME_OTHER_ROUTE_ENTRY_ID");
  return c.text("Ok");
});
```

Now, if the `routingApp` handles a request, the history array will contain all IDs involved in handling a request for a specific method/URL. Given those IDs, it is possible to generate the code by converting the data structures back into code and include all things that these structures refer to. This way only code is included that might actually get executed for the request.

## Performance

On smaller projects, the source code analysis is quite fast, it might take even less than 100ms. 
However on larger code bases it some calls can suddenly become slow/expensive. One such call is `getProgram`, it's a method on the language service and returns a compiler instance. Even on tiny projects this call can take ~50ms, so the approach taken here is to call `getProgram` as few times as possible and as early as possible. Another thing is the `tsconfig.json` has quite a significant performance impact, especially specifying types using `compilerOptions.types`. Adding `node` types for the simplest project in the test suite added 5ms to the test (bumping it to around 50ms). This brings us to another optimization that was done for larger projects: caching results for `readFile`, `fileExists` and `directoryExists`. These calls happen a lot, while typescript is trying to figure out for instance whether a package exists and where.
So in case of this package, we cache the results of this calls while parsing the source code and reset it when files change on the filesystem.

## The future

It would be nice if we could do things like incremental analysis, right now the second time a code basis is analyzed it is typically a bit faster, but we could simply only analyze files that are related to the files that have been changed since the last time the analysis completed. Even further in the future it could be interesting to use a language that's more performant like Rust that can parse typescript.

## Debug your Hono APIs

Fiberplane Studio is a local debugging companion designed to help you to build, test, and develop [Hono](https://hono.dev) APIs.
It’s open source and available to try now - check out [the getting started guide here](https://fiberplane.com/docs/get-started/).
