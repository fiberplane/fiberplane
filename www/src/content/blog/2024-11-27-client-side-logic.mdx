---
title: "Step-by-step guide: Adding client-side logic to your Hono app"
description: A guide to adding client-side logic to your Hono app.
slug: client-side-logic
date: 2024-11-27
author: Oscar van Zijverden
tags:
  - guide
  - tutorial
  - honc
  - hono
  - javascript
---

import {
  Aside,
  Card,
  FileTree,
  TabItem,
  Tabs
} from "@astrojs/starlight/components";

[Hono](https://hono.dev) is a great framework to build serverless apps with
familiar APIs using Web Standards. It comes with a ton of features out of the
box.\
One of these features is the ability to render JSX server-side, which is great
static content. But what if you want to add some client-side logic to your app?

In this guide we'll go over on how to add client-side logic to a Hono app and
unlock the full potential of your projects.

## What are we building?

We're building an app that uses Hono running in Cloudflare Workers, leveraging
[static asset bindings](https://developers.cloudflare.com/workers/static-assets/binding)
\- though the same principles apply to the other supported environments too.

We'll be adding a route that serves a simple counter component that gets
rendered server-side and hydrated client-side.

This is done by make a distinction between server-side and client-side logic and
adjust our build step to facilitate this.\
We'll be using [Vite](https://vitejs.dev) with a few plugins to make this
happen.

## Let us build!

First, let's get started with scaffolding a new Hono app:

<Tabs syncKey="package-manager">
<TabItem label="npm">

```sh
npm create hono@latest hono-client
```

</TabItem>

<TabItem label="yarn">

```sh
yarn create hono hono-client
```

</TabItem>

<TabItem label="pnpm">

```sh
pnpm create hono hono-client
```

</TabItem>

<TabItem label="bun">

```sh
bunx create-hono hono-client
```

</TabItem>
</Tabs>

<Aside>
  Make sure to select the `cloudflare-workers` template when prompted.
</Aside>

The `src` directory contains a single `index.ts` file with a simple Hono app.
We're adding a `client` directory with an index and component:

<FileTree>

- src
  - index.ts
  - **client**
    - **index.tsx** logic to mount the app on the client
    - **Counter.tsx** component to demonstrate client-side logic

</FileTree>

### Adding component & mounting point

Let's start with setting up a simple counter component that increments a count
when a button is clicked:

```tsx title="src/client/Counter.tsx"
import { useState } from "hono/jsx";

export function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)} type="button">
        Increase count
      </button>
      <span>Count: {count}</span>
    </div>
  );
}
```

Then we import the component & hydrate it in the client entry file:

```tsx title="src/client/index.tsx"
import { StrictMode } from "hono/jsx";
import { hydrateRoot } from "hono/jsx/dom/client";

import { Counter } from "./Counter";

const root = document.getElementById("root");
if (!root) {
  throw new Error("Root element not found");
}

hydrateRoot(
  root,
  <StrictMode>
    <Counter />
  </StrictMode>
);
```

<Aside>
  We're _hydrating_ the app as opposed to _rendering_ it, as we'll render the
  component server-side with Hono. If you're interested in client-side rendering
  only, check out the [example on
  GitHub](https://github.com/oscarvz/cf-workers-hono-client-side).
</Aside>

Your code editor might give you a hint that `document` is not defined. Given we
added the client-side logic, we need to tell TypeScript that we're running in a
browser environment:

```json title="tsconfig.json" ins={6}
{
  "compilerOptions": {
    //...
    "lib": [
      "ESNext",
      "DOM",
    ],
    // ...
  }
}
```

We're going to add some JSX to the `src/index.ts` file, so we first need to
change the file extension to `.tsx`.
Once that's done, we can add Hono's
[JSX renderer middleware](https://hono.dev/docs/middleware/builtin/jsx-renderer)
to the `/` route and return the statically rendered `<Counter />` component:

```tsx title="src/index.tsx" ins={2, 4, 8-23, 26} del={25}
import { Hono } from "hono";
import { jsxRenderer } from "hono/jsx-renderer";

import { Counter } from "./client/Counter";

const app = new Hono();

app.use(
  jsxRenderer(
    ({ children }) => (
      <html lang="en">
        <head>
          <meta charSet="utf-8" />
          <meta content="width=device-width, initial-scale=1" name="viewport" />
          <title>hono-client</title>
        </head>
        <div id="root">{children}</div>
      </html>
    ),
    { docType: true }
  )
);

app.get("/", (c) => {
  return c.text("Hello Hono!");
  return c.render(<Counter />);
});

export default app;
```

We're almost there. If you run the app now with the `dev` script, you'll get an
error. Let's fix that by fixing the build steps!

### Adding build steps and scripts

At this point we both have server-side and client-side logic, and need to add
two build steps to our project. Let's install Vite and two plugins to facilitate
this:

<Tabs syncKey="package-manager">
<TabItem label="npm">
```sh
npm install vite
npm install -D @hono/vite-build @hono/vite-dev-server
```
</TabItem>

<TabItem label="yarn">
  ```sh yarn add vite yarn add -D @hono/vite-build @hono/vite-dev-server ```
</TabItem>

<TabItem label="pnpm">
  ```sh pnpm add vite pnpm add -D @hono/vite-build @hono/vite-dev-server ```
</TabItem>

<TabItem label="bun">
```sh
bun add vite
bun add -D @hono/vite-build @hono/vite-dev-server
```
</TabItem>
</Tabs>

In the root of your project, create a `vite.config.ts` file. We'll define the
config for both the client-side build and the server-side build.

Note that for the client build the `outDir` is set to `./public`. As mentioned
earlier we're using Cloudflare Workers with static asset bindings. If we're not
defining these bindings ourselves, the worker will automagically find the built
files in the `public` directory.

```ts title="vite.config.ts"
import build from "@hono/vite-build/cloudflare-workers";
import devServer from "@hono/vite-dev-server";
import cloudflareAdapter from "@hono/vite-dev-server/cloudflare";
import { defineConfig } from "vite";

export default defineConfig(({ mode }) => {
  if (mode === "client") {
    return {
      build: {
        rollupOptions: {
          input: "./src/client/index.tsx"
        },
        outDir: "./public"
      }
    };
  }

  const entry = "./src/index.tsx";
  return {
    server: { port: 8787 },
    plugins: [
      devServer({ adapter: cloudflareAdapter, entry }),
      build({ entry })
    ]
  };
});
```

<Aside type="tip">
  This would be a good moment to add the `public` directory to your
  `.gitignore`.
</Aside>

Now we need to adjust the `package.json` scripts to facilitate the new build
steps. Additionally, we set the type to `module` to allow for ESM imports:

```json title="package.json" del={5} ins={3, 6, 7}
{
  "name": "hono-client",
  "type": "module",
  "scripts": {
    "dev": "wrangler dev",
    "dev": "vite dev",
    "build": "vite build --mode client && vite build",
    "deploy": "wrangler deploy --minify"
  }
  // ...
}
```

### Access the built script

As a final step we need to load the client-side script. We'll add a script tag
to the JSX renderer.\
We need to make a distinction between a development and
production environment. Vite allows us to do this easily with it's
[built-in env](https://vite.dev/guide/env-and-mode#env-variables).
For the dev environment we can load the client's `.tsx` file; for production we
can get it from the `public` directory.

First we add the `vite/client` types to the TypeScript config:

```json file="tsconfig.json" ins={6}
{
  "compilerOptions": {
    //...
    "types": [
      // ...
      "vite/client"
    ]
    //...
  }
}
```

Then we adjust the `src/index.tsx` file to load the client-side script,
depending on the environment:

```tsx title="src/index.tsx" ins={11-18}
// ...
app.use(
  jsxRenderer(
    ({ children }) => (
      <html lang="en">
        <head>
          <meta charSet="utf-8" />
          <meta content="width=device-width, initial-scale=1" name="viewport" />
          <title>hono-client</title>

          <script
            type="module"
            src={
              import.meta.env.PROD
                ? "/assets/index.js"
                : "/src/client/index.tsx"
            }
          />
        </head>
        <body>
          <div id="root">{children}</div>
        </body>
      </html>
    ),
    { docType: true }
  )
);
// ...
```

#### Run locally

That's it! You can now run the app with the `dev` script and see the counter
component in action.

<Tabs syncKey="package-manager">
<TabItem label="npm">

```sh
npm run dev
```

</TabItem>

<TabItem label="yarn">

```sh
yarn dev
```

</TabItem>

<TabItem label="pnpm">

```sh
pnpm dev
```

</TabItem>

<TabItem label="bun">

```sh
bun dev
```

</TabItem>
</Tabs>

## Deploying

To deploy the app to Cloudflare Workers we have to update `wrangler.toml` so it
points to the correct worker build, and update the `deploy` script.

```toml title="wrangler.toml" del={2} ins={3}
name = "hono-client"
main = "src/index.ts"
main = "dist/index.js"
# ...
```

```json title="package.json" del={6} ins={7}
{
  // ...
  "scripts": {
    "dev": "vite dev",
    "build": "vite build --mode client && vite build",
    "deploy": "wrangler deploy --minify",
    "deploy": "$npm_execpath run build && wrangler deploy --no-bundle"
  }
  // ...
}
```

<Aside>
Note that the `wrangler deploy` has the ``--no-bundle`` flag. The build is done
by Vite, so we don't need Wrangler to bundle the code; merely deploy it to the
Cloudflare Workers platform.
</Aside>

<Card title="GitHub repo" icon="github">
Check out the [GitHub example repo](https://github.com/oscarvz/cf-workers-hono-client-side)
if you'd like to see the full application code. It has a few additional
features, like Hono's RPC implementation, and a SPA example.
</Card>
