// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`api 1`] = `
{
  "errorCount": 0,
  "results": [
    {
      "entries": [
        {
          "method": "get",
          "path": "/v0/app-routes",
          "sources": [
            {
              "character": 26,
              "content": "async (ctx) => {
  const db = ctx.get("db");
  const routes = await db.select().from(appRoutes);
  const baseUrl = resolveServiceArg(
    env(ctx).FPX_SERVICE_TARGET as string,
    "http://localhost:8787",
  );
  return ctx.json({
    baseUrl,
    routes,
  });
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/app-routes.ts",
              "line": 41,
              "modules": {
                "hono": [
                  {
                    "import": "env",
                    "importPath": "hono/adapter",
                    "name": "hono",
                    "version": "4.6.2",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
        {
          "method": "post",
          "path": "/v0/app-routes",
          "sources": [
            {
              "character": 2,
              "content": "zValidator(
    "json",
    z.union([appRoutesInsertSchema, z.array(appRoutesInsertSchema)]),
  )",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/app-routes.ts",
              "line": 56,
              "modules": {
                "@hono/zod-validator": {
                  "import": "zValidator",
                  "importPath": "@hono/zod-validator",
                  "name": "@hono/zod-validator",
                  "version": "0.2.2",
                },
              },
              "references": [],
            },
            {
              "character": 2,
              "content": "async (ctx) => {
    const db = ctx.get("db");
    const submitted = ctx.req.valid("json");
    // NOTE: drizzle should handle this for us, but it doesn't seem to be working...
    if (Array.isArray(submitted)) {
      const createdRoutes = await db
        .insert(appRoutes)
        .values(submitted)
        .returning();
      return ctx.json(createdRoutes);
    }

    const createdRoute = await db
      .insert(appRoutes)
      .values(submitted)
      .returning();
    return ctx.json(createdRoute?.[0]);
  }",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/app-routes.ts",
              "line": 60,
              "modules": {},
              "references": [],
            },
          ],
        },
        {
          "method": "post",
          "path": "/v0/probed-routes",
          "sources": [
            {
              "character": 2,
              "content": "zValidator("json", schemaProbedRoutes)",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/app-routes.ts",
              "line": 82,
              "modules": {
                "@hono/zod-validator": {
                  "import": "zValidator",
                  "importPath": "@hono/zod-validator",
                  "name": "@hono/zod-validator",
                  "version": "0.2.2",
                },
              },
              "references": [],
            },
            {
              "character": 2,
              "content": "async (ctx) => {
    const db = ctx.get("db");
    const { routes } = ctx.req.valid("json");

    try {
      if (routes.length > 0) {
        // "Re-register" all current app routes in a database transaction
        await reregisterRoutes(db, { routes });

        // TODO - Detect if anything actually changed before invalidating the query on the frontend
        //        This would be more of an optimization, but is friendlier to the frontend
        const wsConnections = ctx.get("wsConnections");

        if (wsConnections) {
          for (const ws of wsConnections) {
            ws.send(
              JSON.stringify({
                event: "trace_created",
                payload: ["appRoutes"],
              }),
            );
          }
        }
      }

      return ctx.text("OK");
    } catch (err) {
      if (err instanceof Error) {
        logger.error("Error processing probed routes", err);
      }
      return ctx.json({ error: "Error processing probed routes" }, 500);
    }
  }",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/app-routes.ts",
              "line": 83,
              "modules": {},
              "references": [],
            },
          ],
        },
        {
          "method": "get",
          "path": "/v0/all-requests",
          "sources": [
            {
              "character": 28,
              "content": "async (ctx) => {
  const db = ctx.get("db");
  const requests = await db
    .select()
    .from(appResponses)
    .rightJoin(appRequests, eq(appResponses.requestId, appRequests.id))
    .limit(1000);
  return ctx.json(requests);
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/app-routes.ts",
              "line": 144,
              "modules": {
                "drizzle-orm": [
                  {
                    "import": "eq",
                    "importPath": "drizzle-orm",
                    "name": "drizzle-orm",
                    "version": "0.33.0",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
        {
          "method": "all",
          "path": "/v0/proxy-request/*",
          "sources": [
            {
              "character": 2,
              "content": "zValidator("header", ProxyRequestHeadersSchema)",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/app-routes.ts",
              "line": 197,
              "modules": {
                "@hono/zod-validator": {
                  "import": "zValidator",
                  "importPath": "@hono/zod-validator",
                  "name": "@hono/zod-validator",
                  "version": "0.2.2",
                },
              },
              "references": [],
            },
            {
              "character": 2,
              "content": "async (ctx) => {
    const {
      "x-fpx-trace-id": traceIdHeader,
      "x-fpx-proxy-to": proxyToHeader,
      "x-fpx-path-params": pathParamsHeader,
      "x-fpx-route": routeHeader,
      "x-fpx-headers-json": headersJsonHeader,
    } = ctx.req.valid("header");
    // Try to extract the trace id from the header, otherwise generate a new one
    const shouldUseHeaderTraceId = isValidOtelTraceId(traceIdHeader ?? "");
    const traceId: string =
      traceIdHeader && shouldUseHeaderTraceId
        ? traceIdHeader
        : generateOtelTraceId();

    if (!shouldUseHeaderTraceId) {
      logger.debug(
        \`Invalid trace id in header: \${traceIdHeader}, generating new trace id: \${traceId}\`,
      );
    }

    const db = ctx.get("db");

    const requestRoute = routeHeader ?? null;
    const requestPathParams = pathParamsHeader
      ? safeParseJson(pathParamsHeader)
      : null;

    const requestMethod = ctx.req.method;
    const requestUrlHeader = proxyToHeader;

    // NOTE - These are the headers that will be used in the request to the service
    const requestHeaders: Record<string, string> =
      constructProxiedRequestHeaders(ctx, headersJsonHeader ?? "", traceId);

    // Construct the url we want to proxy to, using the query params from the original request
    const requestQueryParams = {
      ...ctx.req.query(),
    };
    const requestUrl = resolveUrlQueryParams(
      requestUrlHeader,
      requestQueryParams,
    );
    logger.debug("Proxying request to:", requestUrl);
    logger.debug("Proxying request with headers:", requestHeaders);

    // Create a new request object
    // Clone the incoming request, so we can make a proxy Request object
    const clonedReq = ctx.req.raw.clone();
    const proxiedReq = new Request(requestUrl, {
      method: requestMethod,
      headers: new Headers(requestHeaders),
      body: clonedReq.body ? clonedReq.body.tee()[0] : null,
    });

    // Extract the request body based on content type
    // *The whole point of this is to serialize the request body into the database, for future reference*
    //
    let requestBody:
      | null
      | string
      | {
          [x: string]: string | SerializedFile | (string | SerializedFile)[];
        } = null;
    try {
      requestBody = await serializeRequestBodyForFpxDb(ctx);
    } catch (error) {
      requestBody = "<failed to parse>";
      logger.error("Failed to serialize request body", error);
    }

    // Record request details
    const newRequest: NewAppRequest = {
      // @ts-expect-error - Trust me, the request method is correct, and it's a string
      requestMethod,
      requestUrl,
      requestHeaders,
      requestPathParams,
      requestQueryParams,
      requestBody,
      requestRoute,
      updatedAt: new Date().toISOString(),
      createdAt: new Date().toISOString(),
    };

    const insertResult = await db
      .insert(appRequests)
      .values(newRequest)
      .returning({ requestId: appRequests.id });

    const requestId = insertResult[0].requestId;

    const startTime = Date.now();
    try {
      // Proxy the request
      const response = await executeProxyRequest(proxiedReq);

      // Clone the response and prepare to return it
      const clonedResponse = response.clone();

      const newHeaders = new Headers(clonedResponse.headers);

      // HACK - Frontend often couldn't parse the body because of encoding mismatch
      newHeaders.delete("content-encoding");
      // HACK - Having an explicit content length could mess up the frontend
      //        when the body is a stream ((this happened when running a hono app on Deno))
      newHeaders.delete("content-length");

      const proxiedResponse = new Response(clonedResponse.body, {
        status: response.status,
        statusText: response.statusText,
        headers: newHeaders,
      });
      const duration = Date.now() - startTime;

      await handleSuccessfulRequest(db, requestId, duration, response, traceId);

      proxiedResponse.headers.set("x-fpx-trace-id", traceId);

      return proxiedResponse;
    } catch (fetchError) {
      logger.debug("Error executing proxied request (fetchError):", fetchError);
      const responseTime = Date.now() - startTime;
      const { failureDetails, failureReason, isFailure } =
        await handleFailedRequest(
          db,
          requestId,
          traceId,
          responseTime,
          fetchError,
        );

      ctx.header("x-fpx-trace-id", traceId);
      ctx.status(500);
      return ctx.json({
        isFailure,
        responseTime,
        failureDetails,
        failureReason,
        traceId,
        requestId,
      });
    }
  }",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/app-routes.ts",
              "line": 198,
              "modules": {},
              "references": [],
            },
          ],
        },
        {
          "method": "get",
          "path": "/v0/webhonc",
          "sources": [
            {
              "character": 23,
              "content": "async (ctx) => {
  const db = ctx.get("db");
  const connectionId = await getWebHoncConnectionId(db);
  const baseUrl = resolveWebhoncUrl();
  const protocol = baseUrl.startsWith("localhost") ? "http" : "https";
  return ctx.json({ webhoncUrl: \`\${protocol}://\${baseUrl}/\${connectionId}\` });
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/app-routes.ts",
              "line": 344,
              "modules": {},
              "references": [],
            },
          ],
        },
      ],
      "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/app-routes.ts",
      "name": "app",
    },
    {
      "entries": [
        {
          "method": "post",
          "path": "/v0/expand-function",
          "sources": [
            {
              "character": 32,
              "content": "cors()",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/inference/inference.ts",
              "line": 19,
              "modules": {
                "hono": {
                  "import": "cors",
                  "importPath": "hono/cors",
                  "name": "hono",
                  "version": "4.6.2",
                },
              },
              "references": [],
            },
            {
              "character": 40,
              "content": "async (ctx) => {
  const { handler } = await ctx.req.json();
  const projectRoot = USER_PROJECT_ROOT_DIR;

  const expandedFunction = await expandFunction(projectRoot, handler);
  return ctx.json({ expandedFunction });
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/inference/inference.ts",
              "line": 19,
              "modules": {},
              "references": [],
            },
          ],
        },
        {
          "method": "post",
          "path": "/v0/generate-request",
          "sources": [
            {
              "character": 2,
              "content": "cors()",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/inference/inference.ts",
              "line": 47,
              "modules": {
                "hono": {
                  "import": "cors",
                  "importPath": "hono/cors",
                  "name": "hono",
                  "version": "4.6.2",
                },
              },
              "references": [],
            },
            {
              "character": 2,
              "content": "zValidator("json", generateRequestSchema)",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/inference/inference.ts",
              "line": 48,
              "modules": {
                "@hono/zod-validator": {
                  "import": "zValidator",
                  "importPath": "@hono/zod-validator",
                  "name": "@hono/zod-validator",
                  "version": "0.2.2",
                },
              },
              "references": [],
            },
            {
              "character": 2,
              "content": "async (ctx) => {
    const { handler, method, path, history, persona, openApiSpec, middleware } =
      ctx.req.valid("json");

    const db = ctx.get("db");
    const inferenceConfig = await getInferenceConfig(db);

    if (!inferenceConfig) {
      return ctx.json(
        {
          message: "No inference configuration found",
        },
        403,
      );
    }

    // Expand out of scope identifiers in the handler function, to add as additional context
    //
    // Uncomment console.time to see how long this takes
    // It should be slow on the first request, but fast-ish on subsequent requests
    //
    // console.time("Handler and Middleware Expansion");
    const [handlerContextPerformant, middlewareContextPerformant] =
      await expandHandler(handler, middleware ?? []).catch((error) => {
        logger.error(\`Error expanding handler and middleware: \${error}\`);
        return [null, null];
      });
    // console.timeEnd("Handler and Middleware Expansion");

    // Generate the request
    const { data: parsedArgs, error: generateError } =
      await generateRequestWithAiProvider({
        inferenceConfig,
        persona,
        method,
        path,
        handler,
        handlerContext: handlerContextPerformant ?? undefined,
        history: history ?? undefined,
        openApiSpec: openApiSpec ?? undefined,
        middleware: middleware ?? undefined,
        middlewareContext: middlewareContextPerformant ?? undefined,
      });

    if (generateError) {
      return ctx.json({ message: generateError.message }, 500);
    }

    return ctx.json({
      request: parsedArgs,
    });
  }",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/inference/inference.ts",
              "line": 49,
              "modules": {},
              "references": [],
            },
          ],
        },
        {
          "method": "post",
          "path": "/v0/analyze-error",
          "sources": [
            {
              "character": 2,
              "content": "cors()",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/inference/inference.ts",
              "line": 105,
              "modules": {
                "hono": {
                  "import": "cors",
                  "importPath": "hono/cors",
                  "name": "hono",
                  "version": "4.6.2",
                },
              },
              "references": [],
            },
            {
              "character": 2,
              "content": "zValidator(
    "json",
    z.object({ errorMessage: z.string(), handlerSourceCode: z.string() }),
  )",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/inference/inference.ts",
              "line": 106,
              "modules": {
                "@hono/zod-validator": {
                  "import": "zValidator",
                  "importPath": "@hono/zod-validator",
                  "name": "@hono/zod-validator",
                  "version": "0.2.2",
                },
              },
              "references": [],
            },
            {
              "character": 2,
              "content": "async (ctx) => {
    const { handlerSourceCode, errorMessage } = ctx.req.valid("json");

    const db = ctx.get("db");
    const inferenceConfig = await getInferenceConfig(db);
    if (!inferenceConfig) {
      return ctx.json(
        {
          error: "No OpenAI configuration found",
        },
        403,
      );
    }
    const { openaiApiKey, openaiModel } = inferenceConfig;
    const openaiClient = new OpenAI({
      apiKey: openaiApiKey,
    });
    const response = await openaiClient.chat.completions.create({
      model: openaiModel ?? "gpt-4o", // TODO - Update this to use correct model and provider (later problem)
      messages: [
        {
          role: "system",
          content: cleanPrompt(\`
            You are a code debugging assistant for apps that use Hono (web framework),
            Neon (serverless postgres), Drizzle (ORM), and run on Cloudflare workers.
            You are given a function and an error message.
            Provide a succinct suggestion to fix the error, or say "I need more context to help fix this".
          \`),
        },
        {
          role: "user",
          content: cleanPrompt(\`
            I hit the following error:
            \${errorMessage}
            This error originated in the following route handler for my Hono application:
            \${handlerSourceCode}
          \`),
        },
      ],
      temperature: 0,
      max_tokens: 2048,
    });

    const {
      choices: [{ message }],
    } = response;

    return ctx.json({
      suggestion: message.content,
    });
  }",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/inference/inference.ts",
              "line": 110,
              "modules": {},
              "references": [],
            },
          ],
        },
      ],
      "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/inference/inference.ts",
      "name": "app",
    },
    {
      "entries": [
        {
          "method": "get",
          "path": "/v0/settings",
          "sources": [
            {
              "character": 24,
              "content": "cors()",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/settings.ts",
              "line": 12,
              "modules": {
                "hono": {
                  "import": "cors",
                  "importPath": "hono/cors",
                  "name": "hono",
                  "version": "4.6.2",
                },
              },
              "references": [],
            },
            {
              "character": 32,
              "content": "async (ctx) => {
  const db = ctx.get("db");
  const settingsRecord = await getAllSettings(db);
  return ctx.json(settingsRecord);
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/settings.ts",
              "line": 12,
              "modules": {},
              "references": [],
            },
          ],
        },
        {
          "method": "post",
          "path": "/v0/settings",
          "sources": [
            {
              "character": 25,
              "content": "cors()",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/settings.ts",
              "line": 23,
              "modules": {
                "hono": {
                  "import": "cors",
                  "importPath": "hono/cors",
                  "name": "hono",
                  "version": "4.6.2",
                },
              },
              "references": [],
            },
            {
              "character": 33,
              "content": "async (ctx) => {
  const currentSettings = await getAllSettings(ctx.get("db"));
  const prevProxyUrlEnabled = currentSettings?.proxyRequestsEnabled;

  const { content } = (await ctx.req.json()) as {
    content: Record<string, string>;
  };

  const parsedContent = SettingsSchema.parse(content);
  // Remove the stored api key if the feature is disabled
  if (!parsedContent.aiEnabled) {
    parsedContent.openaiApiKey = undefined;
    parsedContent.anthropicApiKey = undefined;
  }

  logger.debug("Updating settings", { content });

  const db = ctx.get("db");
  const webhonc = ctx.get("webhonc");

  const updatedSettings = await upsertSettings(db, parsedContent);

  logger.debug("Configuration updated...");

  // HACK - We should techincally JSON parse the value here, but whatever.
  const proxyUrlEnabled =
    updatedSettings.find((setting) => setting.key === "proxyRequestsEnabled")
      ?.value === "true";

  const shouldStartWebhonc = !prevProxyUrlEnabled && proxyUrlEnabled;
  if (shouldStartWebhonc) {
    logger.debug("Proxy requests enabled in settings update, starting webhonc");
    await webhonc.start();
  }

  const shouldStopWebhonc = prevProxyUrlEnabled && !proxyUrlEnabled;
  if (shouldStopWebhonc) {
    logger.debug(
      "Proxy requests disabled in settings update, stopping webhonc",
    );
    await webhonc.stop();
  }

  return ctx.json(updatedSettings);
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/settings.ts",
              "line": 23,
              "modules": {
                "@fiberplane/fpx-types": [
                  {
                    "import": "SettingsSchema",
                    "importPath": "@fiberplane/fpx-types",
                    "name": "@fiberplane/fpx-types",
                    "version": "0.0.6",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
      ],
      "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/settings.ts",
      "name": "app",
    },
    {
      "entries": [
        {
          "method": "get",
          "path": "/v0/source",
          "sources": [
            {
              "character": 2,
              "content": "cors()",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/source.ts",
              "line": 14,
              "modules": {
                "hono": {
                  "import": "cors",
                  "importPath": "hono/cors",
                  "name": "hono",
                  "version": "4.6.2",
                },
              },
              "references": [],
            },
            {
              "character": 2,
              "content": "zValidator(
    "query",
    z.object({ source: z.string(), line: z.string(), column: z.string() }),
  )",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/source.ts",
              "line": 15,
              "modules": {
                "@hono/zod-validator": {
                  "import": "zValidator",
                  "importPath": "@hono/zod-validator",
                  "name": "@hono/zod-validator",
                  "version": "0.2.2",
                },
              },
              "references": [],
            },
            {
              "character": 2,
              "content": "async (ctx) => {
    const { source, line, column } = ctx.req.query();

    try {
      const file = JSON.parse(readFileSync(source, "utf8").toString());
      const consumer = await new SourceMapConsumer(file);
      const pos = consumer.originalPositionFor({
        line: Number.parseInt(line, 10),
        column: Number.parseInt(column, 10),
      });
      consumer.destroy();

      return ctx.json(pos);
    } catch (err) {
      const message = getValueFromObject(err, "message", "Unknown error");
      const name = getValueFromObject(err, "name", "");

      console.error("Could not read source file", message);
      return ctx.json(
        {
          error: "Error reading file",
          name,
          message,
        },
        500,
      );
    }
  }",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/source.ts",
              "line": 19,
              "modules": {
                "node:fs": [
                  {
                    "import": "readFileSync",
                    "importPath": "node:fs",
                    "name": "node:fs",
                  },
                ],
                "source-map": [
                  {
                    "import": "SourceMapConsumer",
                    "importPath": "source-map",
                    "name": "source-map",
                    "version": "0.7.4",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
        {
          "method": "post",
          "path": "/v0/source-function",
          "sources": [
            {
              "character": 32,
              "content": "cors()",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/source.ts",
              "line": 49,
              "modules": {
                "hono": {
                  "import": "cors",
                  "importPath": "hono/cors",
                  "name": "hono",
                  "version": "4.6.2",
                },
              },
              "references": [],
            },
            {
              "character": 40,
              "content": "async (ctx) => {
  const { handler, source } = ctx.req.query();

  try {
    const result = await findSourceFunctions(source, handler);
    return ctx.json({
      functionText: result?.[0]?.sourceFunction ?? null,
    });
  } catch (err) {
    console.error("Could not find function in source", source);
    const message = getValueFromObject(err, "message", "Unknown error");
    const name = getValueFromObject(err, "name", "");

    return ctx.json(
      {
        error: "Error finding function",
        name,
        message,
      },
      500,
    );
  }
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/source.ts",
              "line": 49,
              "modules": {},
              "references": [],
            },
          ],
        },
      ],
      "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/source.ts",
      "name": "app",
    },
    {
      "entries": [
        {
          "method": "get",
          "path": "/v1/traces",
          "sources": [
            {
              "character": 22,
              "content": "async (ctx) => {
  const db = ctx.get("db");

  const fpxWorker = await getSetting(db, "fpxWorkerProxy");
  if (fpxWorker?.enabled && fpxWorker.baseUrl) {
    const response = await fetch(\`\${fpxWorker.baseUrl}/v1/traces\`);
    const json = await response.json();
    return ctx.json(json);
  }

  const spans = await db.query.otelSpans.findMany({
    where: sql\`inner->>'scope_name' = 'fpx-tracer'\`,
    orderBy: desc(sql\`inner->>'end_time'\`),
  });

  const traceMap = new Map<string, Array<(typeof spans)[0]>>();

  for (const span of spans) {
    const traceId = span.inner.trace_id;
    if (!traceId) {
      continue;
    }
    if (!traceMap.has(traceId)) {
      traceMap.set(traceId, []);
    }
    traceMap.get(traceId)?.push(span);
  }

  const traces = Array.from(traceMap.entries()).map(([traceId, spans]) => ({
    traceId,
    spans,
  }));

  const response: TraceListResponse = traces.map(({ traceId, spans }) => ({
    traceId,
    spans: spans.map(({ inner }) => OtelSpanSchema.parse(inner)),
  }));

  return ctx.json(response);
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/traces.ts",
              "line": 24,
              "modules": {
                "@fiberplane/fpx-types": [
                  {
                    "import": "TraceListResponse",
                    "importPath": "@fiberplane/fpx-types",
                    "name": "@fiberplane/fpx-types",
                    "version": "0.0.6",
                  },
                  {
                    "import": "OtelSpanSchema",
                    "importPath": "@fiberplane/fpx-types",
                    "name": "@fiberplane/fpx-types",
                    "version": "0.0.6",
                  },
                ],
                "drizzle-orm": [
                  {
                    "import": "sql",
                    "importPath": "drizzle-orm",
                    "name": "drizzle-orm",
                    "version": "0.33.0",
                  },
                  {
                    "import": "desc",
                    "importPath": "drizzle-orm",
                    "name": "drizzle-orm",
                    "version": "0.33.0",
                  },
                  {
                    "import": "sql",
                    "importPath": "drizzle-orm",
                    "name": "drizzle-orm",
                    "version": "0.33.0",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
        {
          "method": "get",
          "path": "/v1/traces/:traceId/spans",
          "sources": [
            {
              "character": 37,
              "content": "async (ctx) => {
  const traceId = ctx.req.param("traceId");

  const db = ctx.get("db");

  const fpxWorker = await getSetting(db, "fpxWorkerProxy");
  if (fpxWorker?.enabled && fpxWorker.baseUrl) {
    const response = await fetch(
      \`\${fpxWorker.baseUrl}/v1/traces/\${traceId}/spans\`,
    );
    const json = await response.json();
    return ctx.json(json);
  }

  const traces = await db
    .select()
    .from(otelSpans)
    .where(
      and(
        sql\`inner->>'scope_name' = 'fpx-tracer'\`,
        sql\`inner->>'trace_id' = \${traceId}\`,
      ),
    );

  const response: TraceDetailSpansResponse = traces.map(({ inner }) =>
    OtelSpanSchema.parse(inner),
  );

  return ctx.json(response);
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/traces.ts",
              "line": 70,
              "modules": {
                "@fiberplane/fpx-types": [
                  {
                    "import": "TraceDetailSpansResponse",
                    "importPath": "@fiberplane/fpx-types",
                    "name": "@fiberplane/fpx-types",
                    "version": "0.0.6",
                  },
                  {
                    "import": "OtelSpanSchema",
                    "importPath": "@fiberplane/fpx-types",
                    "name": "@fiberplane/fpx-types",
                    "version": "0.0.6",
                  },
                ],
                "drizzle-orm": [
                  {
                    "import": "and",
                    "importPath": "drizzle-orm",
                    "name": "drizzle-orm",
                    "version": "0.33.0",
                  },
                  {
                    "import": "sql",
                    "importPath": "drizzle-orm",
                    "name": "drizzle-orm",
                    "version": "0.33.0",
                  },
                  {
                    "import": "sql",
                    "importPath": "drizzle-orm",
                    "name": "drizzle-orm",
                    "version": "0.33.0",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
        {
          "method": "post",
          "path": "/v1/traces/delete-all-hack",
          "sources": [
            {
              "character": 39,
              "content": "async (ctx) => {
  const db = ctx.get("db");
  await db.delete(otelSpans);
  return ctx.text("OK");
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/traces.ts",
              "line": 101,
              "modules": {},
              "references": [],
            },
          ],
        },
        {
          "method": "post",
          "path": "/v1/traces",
          "sources": [
            {
              "character": 23,
              "content": "async (ctx) => {
  const db = ctx.get("db");
  const body: IExportTraceServiceRequest = await ctx.req.json();

  const fpxWorker = await getSetting(db, "fpxWorkerProxy");
  if (fpxWorker?.enabled && fpxWorker.baseUrl) {
    const response = await fetch(\`\${fpxWorker.baseUrl}/v1/traces\`, {
      headers: {
        "Content-Type": "application/json",
      },
      method: "POST",
      body: JSON.stringify(body),
    });
    const json = await response.json();
    return ctx.json(json);
  }

  try {
    const tracesPayload = (await fromCollectorRequest(body)).map(
      (span) =>
        ({
          inner: OtelSpanSchema.parse(span),
          spanId: span.span_id,
          traceId: span.trace_id,
        }) satisfies typeof otelSpans.$inferInsert,
    );

    try {
      await db.insert(otelSpans).values(tracesPayload);
    } catch (error) {
      logger.error("Error inserting trace", error);
      return ctx.text("Error inserting trace", 500);
    }

    const wsConnections = ctx.get("wsConnections");
    if (wsConnections) {
      for (const ws of wsConnections) {
        ws.send(
          JSON.stringify({
            event: "trace_created",
            payload: ["mizuTraces"],
          }),
        );
      }
    }

    return ctx.text("OK");
  } catch (error) {
    logger.error("Error parsing trace data", error);
    return ctx.text("Error parsing trace data", 400);
  }
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/traces.ts",
              "line": 110,
              "modules": {
                "@fiberplane/fpx-types": [
                  {
                    "import": "OtelSpanSchema",
                    "importPath": "@fiberplane/fpx-types",
                    "name": "@fiberplane/fpx-types",
                    "version": "0.0.6",
                  },
                ],
                "@opentelemetry/otlp-transformer": [
                  {
                    "import": "IExportTraceServiceRequest",
                    "importPath": "@opentelemetry/otlp-transformer",
                    "name": "@opentelemetry/otlp-transformer",
                    "version": "0.52.1",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
      ],
      "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/routes/traces.ts",
      "name": "app",
    },
    {
      "entries": [],
      "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/app.ts",
      "name": "app",
    },
    {
      "entries": [
        {
          "method": "get",
          "path": "*",
          "sources": [],
        },
      ],
      "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/api/src/index.node.ts",
      "name": "app",
    },
  ],
}
`;

exports[`bindings 1`] = `
{
  "errorCount": 0,
  "results": [
    {
      "entries": [
        {
          "method": "get",
          "path": "/",
          "sources": [
            {
              "character": 13,
              "content": "(c) => {
  const headers = new Headers();
  c.env.GOOSE_AVATARS.put("test", new ReadableStream(), {
    httpMetadata: { contentType: "application/json" },
  });
  console.log('headers', headers);
  return c.text("Hello, Hono!")
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/lsp-analysis/test/test-case/bindings/index.ts",
              "line": 10,
              "modules": {},
              "references": [],
            },
          ],
        },
      ],
      "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/lsp-analysis/test/test-case/bindings/index.ts",
      "name": "app",
    },
  ],
}
`;

exports[`goose quotes 1`] = `
{
  "errorCount": 0,
  "results": [
    {
      "entries": [
        {
          "method": "get",
          "path": "/",
          "sources": [
            {
              "character": 13,
              "content": "(c) => {
  const honk = shouldHonk(c.req) ? "Honk honk!" : "";
  console.log(\`Home page accessed. Honk: \${honk}\`);
  return c.text(\`Hello Goose Quotes! \${honk}\`.trim());
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/examples/goose-quotes/src/index.ts",
              "line": 33,
              "modules": {},
              "references": [],
            },
          ],
        },
        {
          "method": "get",
          "path": "/api/geese",
          "sources": [
            {
              "character": 22,
              "content": "async (c) => {
  const sql = neon(c.env.DATABASE_URL);
  const db = drizzle(sql);

  const name = c.req.query("name");
  console.log({ action: "search_geese", name });

  if (!name) {
    const allGeese = await measure("getAllGeese", () => getAllGeese(db))();
    console.log({ action: "get_all_geese", count: allGeese.length });
    return c.json(allGeese);
  }

  const searchResults = await measure("searchGeese", () =>
    db
      .select()
      .from(geese)
      .where(ilike(geese.name, \`%\${name}%\`))
      .orderBy(asc(geese.name)),
  )();

  console.log({
    action: "search_geese_results",
    count: searchResults.length,
    name,
  });

  return c.json(searchResults);
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/examples/goose-quotes/src/index.ts",
              "line": 44,
              "modules": {
                "@fiberplane/hono-otel": [
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                ],
                "@neondatabase/serverless": [
                  {
                    "import": "neon",
                    "importPath": "@neondatabase/serverless",
                    "name": "@neondatabase/serverless",
                    "version": "0.9.4",
                  },
                ],
                "drizzle-orm": [
                  {
                    "import": "drizzle",
                    "importPath": "drizzle-orm/neon-http",
                    "name": "drizzle-orm",
                    "version": "0.32.2",
                  },
                  {
                    "import": "ilike",
                    "importPath": "drizzle-orm",
                    "name": "drizzle-orm",
                    "version": "0.32.2",
                  },
                  {
                    "import": "asc",
                    "importPath": "drizzle-orm",
                    "name": "drizzle-orm",
                    "version": "0.32.2",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
        {
          "method": "get",
          "path": "/api/geese-with-avatar",
          "sources": [
            {
              "character": 34,
              "content": "async (c) => {
  const sql = neon(c.env.DATABASE_URL);
  const db = drizzle(sql);

  console.log("Fetching geese with avatars");

  const geeseWithAvatars = await measure("getGeeseWithAvatars", () =>
    db
      .select()
      .from(geese)
      .where(not(isNull(geese.avatar)))
      .orderBy(asc(geese.id)),
  )();

  console.log(\`Found \${geeseWithAvatars.length} geese with avatars\`);
  return c.json(geeseWithAvatars.map((g) => g.id));
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/examples/goose-quotes/src/index.ts",
              "line": 77,
              "modules": {
                "@fiberplane/hono-otel": [
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                ],
                "@neondatabase/serverless": [
                  {
                    "import": "neon",
                    "importPath": "@neondatabase/serverless",
                    "name": "@neondatabase/serverless",
                    "version": "0.9.4",
                  },
                ],
                "drizzle-orm": [
                  {
                    "import": "drizzle",
                    "importPath": "drizzle-orm/neon-http",
                    "name": "drizzle-orm",
                    "version": "0.32.2",
                  },
                  {
                    "import": "not",
                    "importPath": "drizzle-orm",
                    "name": "drizzle-orm",
                    "version": "0.32.2",
                  },
                  {
                    "import": "isNull",
                    "importPath": "drizzle-orm",
                    "name": "drizzle-orm",
                    "version": "0.32.2",
                  },
                  {
                    "import": "asc",
                    "importPath": "drizzle-orm",
                    "name": "drizzle-orm",
                    "version": "0.32.2",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
        {
          "method": "post",
          "path": "/api/geese",
          "sources": [
            {
              "character": 23,
              "content": "async (c) => {
  const sql = neon(c.env.DATABASE_URL);
  const db = drizzle(sql);

  const { name, isFlockLeader, programmingLanguage, motivations, location } =
    await c.req.json();
  const description = \`A person named \${name} who talks like a Goose\`;

  console.log(\`Creating new goose: \${name}\`);

  const created = await measure("createGoose", () =>
    createGoose(db, {
      name,
      description,
      isFlockLeader,
      programmingLanguage,
      motivations,
      location,
    }),
  )();
  console.log({ action: "create_goose", id: created[0].id, name });
  return c.json(created);
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/examples/goose-quotes/src/index.ts",
              "line": 100,
              "modules": {
                "@fiberplane/hono-otel": [
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                ],
                "@neondatabase/serverless": [
                  {
                    "import": "neon",
                    "importPath": "@neondatabase/serverless",
                    "name": "@neondatabase/serverless",
                    "version": "0.9.4",
                  },
                ],
                "drizzle-orm": [
                  {
                    "import": "drizzle",
                    "importPath": "drizzle-orm/neon-http",
                    "name": "drizzle-orm",
                    "version": "0.32.2",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
        {
          "method": "post",
          "path": "/api/geese/:id/generate",
          "sources": [
            {
              "character": 36,
              "content": "async (c) => {
  const sql = neon(c.env.DATABASE_URL);
  const db = drizzle(sql);

  const id = c.req.param("id");

  const goose = await measure("getGooseById", () => getGooseById(db, +id))();

  if (!goose) {
    console.warn(\`Goose not found: \${id}\`);
    return c.json({ message: "Goose not found" }, 404);
  }

  const { name: gooseName } = goose;

  const openaiClient = new OpenAI({
    apiKey: c.env.OPENAI_API_KEY,
    // HACK - OpenAI freezes fetch when it is imported, so our monkey-patched version needs to be passed here
    fetch: globalThis.fetch,
  });

  console.log(\`Generating quotes for goose: \${gooseName}\`);

  const response = await measure("generateQuotes", () =>
    openaiClient.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content: trimPrompt(\`
              You are a goose. You are a very smart goose. You are part goose, part AI. You are a GooseAI.
              You are also influenced heavily by the work of \${gooseName}.

              Always respond without preamble. If I ask for a list, give me a newline-separated list. That's it.
              Don't number it. Don't bullet it. Just newline it.

              Never forget to Honk. A lot.
          \`),
        },
        {
          role: "user",
          content: trimPrompt(\`
              Reimagine five famous quotes by \${gooseName}, except with significant goose influence.
          \`),
        },
      ],
      temperature: 0.7,
      max_tokens: 2048,
    }),
  )();

  const quotes = response.choices[0].message.content
    ?.split("\\n")
    .filter((quote) => quote.length > 0);
  console.log({
    action: "generate_quotes",
    gooseName,
    quoteCount: quotes?.length,
  });
  return c.json({ name: goose.name, quotes });
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/examples/goose-quotes/src/index.ts",
              "line": 127,
              "modules": {
                "@fiberplane/hono-otel": [
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                ],
                "@neondatabase/serverless": [
                  {
                    "import": "neon",
                    "importPath": "@neondatabase/serverless",
                    "name": "@neondatabase/serverless",
                    "version": "0.9.4",
                  },
                ],
                "drizzle-orm": [
                  {
                    "import": "drizzle",
                    "importPath": "drizzle-orm/neon-http",
                    "name": "drizzle-orm",
                    "version": "0.32.2",
                  },
                ],
                "openai": [
                  {
                    "import": "OpenAI",
                    "importPath": "openai",
                    "name": "openai",
                    "version": "4.55.4",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
        {
          "method": "get",
          "path": "/api/geese/flock-leaders",
          "sources": [
            {
              "character": 36,
              "content": "async (c) => {
  const sql = neon(c.env.DATABASE_URL);
  const db = drizzle(sql);

  console.log("Fetching flock leaders");

  const flockLeaders = await measure("getFlockLeaders", () =>
    db.select().from(geese).where(eq(geese.isFlockLeader, true)),
  )();

  console.log(\`Found \${flockLeaders.length} flock leaders\`);

  return c.json(flockLeaders);
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/examples/goose-quotes/src/index.ts",
              "line": 193,
              "modules": {
                "@fiberplane/hono-otel": [
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                ],
                "@neondatabase/serverless": [
                  {
                    "import": "neon",
                    "importPath": "@neondatabase/serverless",
                    "name": "@neondatabase/serverless",
                    "version": "0.9.4",
                  },
                ],
                "drizzle-orm": [
                  {
                    "import": "drizzle",
                    "importPath": "drizzle-orm/neon-http",
                    "name": "drizzle-orm",
                    "version": "0.32.2",
                  },
                  {
                    "import": "eq",
                    "importPath": "drizzle-orm",
                    "name": "drizzle-orm",
                    "version": "0.32.2",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
        {
          "method": "get",
          "path": "/api/geese/:id",
          "sources": [
            {
              "character": 26,
              "content": "async (c) => {
  const sql = neon(c.env.DATABASE_URL);
  const db = drizzle(sql);

  const id = c.req.param("id");

  console.log(\`Fetching goose with id: \${id}\`);

  const goose = await measure("getGooseById", () => getGooseById(db, +id))();

  if (!goose) {
    console.warn(\`Goose not found: \${id}\`);
    return c.json({ message: "Goose not found" }, 404);
  }

  console.log(\`Found goose: \${goose.name}\`);
  return c.json(goose);
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/examples/goose-quotes/src/index.ts",
              "line": 211,
              "modules": {
                "@fiberplane/hono-otel": [
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                ],
                "@neondatabase/serverless": [
                  {
                    "import": "neon",
                    "importPath": "@neondatabase/serverless",
                    "name": "@neondatabase/serverless",
                    "version": "0.9.4",
                  },
                ],
                "drizzle-orm": [
                  {
                    "import": "drizzle",
                    "importPath": "drizzle-orm/neon-http",
                    "name": "drizzle-orm",
                    "version": "0.32.2",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
        {
          "method": "post",
          "path": "/api/geese/:id/bio",
          "sources": [
            {
              "character": 31,
              "content": "async (c) => {
  const sql = neon(c.env.DATABASE_URL);
  const db = drizzle(sql);

  const id = c.req.param("id");

  const goose = await measure("getGooseById", () => getGooseById(db, +id))();

  if (!goose) {
    console.warn(\`Goose not found: \${id}\`);
    return c.json({ message: "Goose not found" }, 404);
  }

  const {
    name: gooseName,
    description,
    programmingLanguage,
    motivations,
    location,
  } = goose;

  console.log(\`Generating bio for goose: \${gooseName}\`);

  const openaiClient = new OpenAI({
    apiKey: c.env.OPENAI_API_KEY,
    fetch: globalThis.fetch,
  });

  const response = await measure("generateBio", () =>
    openaiClient.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content: trimPrompt(\`
              You are a professional bio writer. Your task is to generate a compelling and engaging bio for a goose.
          \`),
        },
        {
          role: "user",
          content: trimPrompt(\`
              Generate a bio for a goose named \${gooseName} with the following details:
              Description: \${description}
              Programming Language: \${programmingLanguage}
              Motivations: \${motivations}
              Location: \${location}
          \`),
        },
      ],
      temperature: 0.7,
      max_tokens: 2048,
    }),
  )();

  const bio = response.choices[0].message.content;

  // Update the goose with the generated bio
  const updatedGoose = await measure("updateGoose", () =>
    updateGoose(db, +id, { bio }),
  )();

  console.log(\`Bio generated and updated for goose: \${gooseName}\`);
  return c.json(updatedGoose);
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/examples/goose-quotes/src/index.ts",
              "line": 233,
              "modules": {
                "@fiberplane/hono-otel": [
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                ],
                "@neondatabase/serverless": [
                  {
                    "import": "neon",
                    "importPath": "@neondatabase/serverless",
                    "name": "@neondatabase/serverless",
                    "version": "0.9.4",
                  },
                ],
                "drizzle-orm": [
                  {
                    "import": "drizzle",
                    "importPath": "drizzle-orm/neon-http",
                    "name": "drizzle-orm",
                    "version": "0.32.2",
                  },
                ],
                "openai": [
                  {
                    "import": "OpenAI",
                    "importPath": "openai",
                    "name": "openai",
                    "version": "4.55.4",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
        {
          "method": "post",
          "path": "/api/geese/:id/honk",
          "sources": [
            {
              "character": 32,
              "content": "async (c) => {
  const sql = neon(c.env.DATABASE_URL);
  const db = drizzle(sql);

  const id = c.req.param("id");
  const goose = await measure("getGooseById", () => getGooseById(db, +id))();

  if (!goose) {
    console.warn(\`Goose not found: \${id}\`);
    return c.json({ message: "Goose not found" }, 404);
  }

  const currentHonks = goose.honks || 0;

  const updatedGoose = await measure("updateGoose", () =>
    updateGoose(db, +id, { honks: currentHonks + 1 }),
  )();

  console.log(
    \`Honk received for goose: \${goose.name}. New honk count: \${updatedGoose.honks}\`,
  );
  return c.json({
    message: \`Honk honk! \${goose.name} honks back at you!\`,
    honks: updatedGoose.honks,
  });
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/examples/goose-quotes/src/index.ts",
              "line": 301,
              "modules": {
                "@fiberplane/hono-otel": [
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                ],
                "@neondatabase/serverless": [
                  {
                    "import": "neon",
                    "importPath": "@neondatabase/serverless",
                    "name": "@neondatabase/serverless",
                    "version": "0.9.4",
                  },
                ],
                "drizzle-orm": [
                  {
                    "import": "drizzle",
                    "importPath": "drizzle-orm/neon-http",
                    "name": "drizzle-orm",
                    "version": "0.32.2",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
        {
          "method": "get",
          "path": "/api/geese/language/:language",
          "sources": [
            {
              "character": 41,
              "content": "async (c) => {
  const sql = neon(c.env.DATABASE_URL);
  const db = drizzle(sql);

  const language = c.req.param("language");

  console.log(\`Fetching geese with programming language: \${language}\`);

  const geeseByLanguage = await measure("getGeeseByLanguage", () =>
    getGeeseByLanguage(db, language),
  )();

  console.log(
    \`Found \${geeseByLanguage.length} geese for language: \${language}\`,
  );
  return c.json(geeseByLanguage);
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/examples/goose-quotes/src/index.ts",
              "line": 370,
              "modules": {
                "@fiberplane/hono-otel": [
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                ],
                "@neondatabase/serverless": [
                  {
                    "import": "neon",
                    "importPath": "@neondatabase/serverless",
                    "name": "@neondatabase/serverless",
                    "version": "0.9.4",
                  },
                ],
                "drizzle-orm": [
                  {
                    "import": "drizzle",
                    "importPath": "drizzle-orm/neon-http",
                    "name": "drizzle-orm",
                    "version": "0.32.2",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
        {
          "method": "post",
          "path": "/api/geese/:id/change-name-url-form",
          "sources": [
            {
              "character": 48,
              "content": "async (c) => {
  const sql = neon(c.env.DATABASE_URL);
  const db = drizzle(sql);

  const id = c.req.param("id");
  const goose = await measure("getGooseById", () => getGooseById(db, +id))();

  if (!goose) {
    console.warn(\`Goose not found: \${id}\`);
    return c.json({ message: "Goose not found" }, 404);
  }

  const form = await c.req.formData() as FormData;
  const name = form.get("name");

  if (!name) {
    console.error("Name is required for changing goose name");
    return c.json({ message: "Name is required" }, 400);
  }

  console.log(\`Changing name of goose \${id} to \${name}\`);
  const updatedGoose = await measure("updateGoose", () =>
    updateGoose(db, +id, { name }),
  )();

  console.log(\`Name changed for goose \${id}\`);
  return c.json(updatedGoose, 200);
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/examples/goose-quotes/src/index.ts",
              "line": 413,
              "modules": {
                "@fiberplane/hono-otel": [
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                ],
                "@neondatabase/serverless": [
                  {
                    "import": "neon",
                    "importPath": "@neondatabase/serverless",
                    "name": "@neondatabase/serverless",
                    "version": "0.9.4",
                  },
                ],
                "drizzle-orm": [
                  {
                    "import": "drizzle",
                    "importPath": "drizzle-orm/neon-http",
                    "name": "drizzle-orm",
                    "version": "0.32.2",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
        {
          "method": "post",
          "path": "/api/geese/:id/avatar",
          "sources": [
            {
              "character": 34,
              "content": "async (c) => {
  const sql = neon(c.env.DATABASE_URL);
  const db = drizzle(sql);

  const id = c.req.param("id");

  const goose = await measure("getGooseById", () => getGooseById(db, +id))();

  if (!goose) {
    console.warn(\`Goose not found: \${id}\`);
    return c.json({ message: "Goose not found" }, 404);
  }

  const { avatar, avatarName } = await c.req.parseBody();
  console.log({ action: "update_avatar", gooseId: id, avatarName });
  // Validate the avatar is a file
  if (!(avatar instanceof File)) {
    console.error(\`Invalid avatar type for goose \${id}: \${typeof avatar}\`);
    return c.json(
      { message: "Avatar must be a file", actualType: typeof avatar },
      422,
    );
  }

  // Validate the avatar is a JPEG, PNG, or GIF
  const allowedTypes = ["image/jpeg", "image/png", "image/gif"];
  if (!allowedTypes.includes(avatar.type)) {
    console.error(\`Invalid avatar file type for goose \${id}: \${avatar.type}\`);
    return c.json({ message: "Avatar must be a JPEG, PNG, or GIF image" }, 422);
  }

  // Get the file extension from the avatar's type
  const fileExtension = avatar.type.split("/")[1];

  // Save the avatar to the bucket
  const bucketKey = \`goose-\${id}-avatar-\${Date.now()}.\${fileExtension}\`;
  await measure("uploadAvatar", () =>
    c.env.GOOSE_AVATARS.put(bucketKey, avatar.stream(), {
      httpMetadata: { contentType: avatar.type },
    }),
  )();

  console.log(\`Avatar uploaded for goose \${id}: \${bucketKey}\`);

  const updatedGoose = await measure("updateGoose", () =>
    updateGoose(db, +id, { avatar: bucketKey }),
  )();

  console.log(\`Avatar updated for goose \${id}\`);
  return c.json(updatedGoose);
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/examples/goose-quotes/src/index.ts",
              "line": 445,
              "modules": {
                "@fiberplane/hono-otel": [
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                ],
                "@neondatabase/serverless": [
                  {
                    "import": "neon",
                    "importPath": "@neondatabase/serverless",
                    "name": "@neondatabase/serverless",
                    "version": "0.9.4",
                  },
                ],
                "drizzle-orm": [
                  {
                    "import": "drizzle",
                    "importPath": "drizzle-orm/neon-http",
                    "name": "drizzle-orm",
                    "version": "0.32.2",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
        {
          "method": "get",
          "path": "/api/geese/:id/avatar",
          "sources": [
            {
              "character": 33,
              "content": "async (c) => {
  const sql = neon(c.env.DATABASE_URL);
  const db = drizzle(sql);

  const id = c.req.param("id");

  const goose = await measure("getGooseById", () => getGooseById(db, +id))();

  if (!goose) {
    console.warn(\`Goose not found: \${id}\`);
    return c.json({ message: "Goose not found" }, 404);
  }

  const avatarKey = goose.avatar;

  if (!avatarKey) {
    console.warn(\`Goose \${id} has no avatar\`);
    return c.json({ message: "Goose has no avatar" }, 404);
  }

  console.log(\`Fetching avatar for goose \${id}: \${avatarKey}\`);

  const avatar = await measure("getAvatar", () =>
    c.env.GOOSE_AVATARS.get(avatarKey),
  )();

  if (!avatar) {
    console.error(\`Avatar not found for goose \${id}: \${avatarKey}\`);
    return c.json({ message: "Goose avatar not found" }, 404);
  }

  console.log(\`Avatar retrieved for goose \${id}\`);
  const responseHeaders = mapR2HttpMetadataToHeaders(avatar.httpMetadata);
  return new Response(avatar.body, {
    headers: responseHeaders,
  });
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/examples/goose-quotes/src/index.ts",
              "line": 500,
              "modules": {
                "@fiberplane/hono-otel": [
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                  {
                    "import": "measure",
                    "importPath": "@fiberplane/hono-otel",
                    "name": "@fiberplane/hono-otel",
                    "version": "0.3.1-beta.2",
                  },
                ],
                "@neondatabase/serverless": [
                  {
                    "import": "neon",
                    "importPath": "@neondatabase/serverless",
                    "name": "@neondatabase/serverless",
                    "version": "0.9.4",
                  },
                ],
                "drizzle-orm": [
                  {
                    "import": "drizzle",
                    "importPath": "drizzle-orm/neon-http",
                    "name": "drizzle-orm",
                    "version": "0.32.2",
                  },
                ],
              },
              "references": [],
            },
          ],
        },
        {
          "method": "all",
          "path": "/always-honk/:echo?",
          "sources": [
            {
              "character": 31,
              "content": "(c) => {
  const echo = c.req.param("echo");
  console.log(\`Always honk endpoint called with echo: \${echo}\`);
  return c.text(\`Honk honk! \${echo ?? ""}\`);
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/examples/goose-quotes/src/index.ts",
              "line": 543,
              "modules": {},
              "references": [],
            },
          ],
        },
        {
          "method": "get",
          "path": "/ws",
          "sources": [
            {
              "character": 2,
              "content": "upgradeWebSocket((c) => {
    return {
      onMessage(event, ws) {
        const { type, payload } = JSON.parse(event.data);
        const sql = neon(c.env.DATABASE_URL);
        const db = drizzle(sql);

        console.log(\`WebSocket message received: \${type}\`);

        switch (type) {
          case "GET_GEESE":
            measure("getAllGeese", () => getAllGeese(db))().then((geese) => {
              console.log(\`Sending \${geese.length} geese over WebSocket\`);
              ws.send(JSON.stringify({ type: "GEESE", payload: geese }));
            });
            break;
          case "CREATE_GOOSE": {
            const {
              name,
              isFlockLeader,
              programmingLanguage,
              motivations,
              location,
            } = payload;
            const description = \`A person named \${name} who talks like a Goose\`;

            console.log(\`Creating new goose via WebSocket: \${name}\`);
            measure("createGoose", () =>
              createGoose(db, {
                name,
                description,
                isFlockLeader,
                programmingLanguage,
                motivations,
                location,
              }),
            )().then((newGoose) => {
              console.log(\`New goose created via WebSocket: \${newGoose[0].id}\`);
              ws.send(JSON.stringify({ type: "NEW_GOOSE", payload: newGoose }));
            });
            break;
          }
          // ... (handle other message types)
          default:
            console.warn(\`Unknown WebSocket message type: \${type}\`);
            break;
        }
      },
      onClose: () => {
        console.log("WebSocket connection closed");
      },
    };
  })",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/examples/goose-quotes/src/index.ts",
              "line": 551,
              "modules": {
                "hono": {
                  "import": "upgradeWebSocket",
                  "importPath": "hono/cloudflare-workers",
                  "name": "hono",
                  "version": "4.5.9",
                },
              },
              "references": [],
            },
          ],
        },
      ],
      "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/examples/goose-quotes/src/index.ts",
      "name": "app",
    },
  ],
}
`;

exports[`module imports 1`] = `
{
  "errorCount": 0,
  "results": [
    {
      "entries": [
        {
          "method": "get",
          "path": "/",
          "sources": [
            {
              "character": 2,
              "content": "() => cors()",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/lsp-analysis/test/test-case/module-imports/index.ts",
              "line": 9,
              "modules": {
                "hono": [
                  {
                    "import": "cors",
                    "importPath": "hono/cors",
                    "name": "hono",
                    "version": "4.6.6",
                  },
                ],
              },
              "references": [],
            },
            {
              "character": 2,
              "content": "(c) => c.text("Hello, Hono!")",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/lsp-analysis/test/test-case/module-imports/index.ts",
              "line": 10,
              "modules": {},
              "references": [],
            },
          ],
        },
        {
          "method": "get",
          "path": "/slow",
          "sources": [
            {
              "character": 17,
              "content": "cors()",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/lsp-analysis/test/test-case/module-imports/index.ts",
              "line": 19,
              "modules": {
                "hono": {
                  "import": "cors",
                  "importPath": "hono/cors",
                  "name": "hono",
                  "version": "4.6.6",
                },
              },
              "references": [],
            },
            {
              "character": 25,
              "content": "async (c) => {
  await sleep(1000);
  return c.text("Hello, Hono (slow)!");
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/lsp-analysis/test/test-case/module-imports/index.ts",
              "line": 19,
              "modules": {},
              "references": [],
            },
          ],
        },
        {
          "method": "get",
          "path": "user/1",
          "sources": [
            {
              "character": 18,
              "content": "cors()",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/lsp-analysis/test/test-case/module-imports/index.ts",
              "line": 25,
              "modules": {
                "hono": {
                  "import": "cors",
                  "importPath": "hono/cors",
                  "name": "hono",
                  "version": "4.6.6",
                },
              },
              "references": [],
            },
            {
              "character": 26,
              "content": "async (c) => {
  const user = await getUser()
  return c.json(user)
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/lsp-analysis/test/test-case/module-imports/index.ts",
              "line": 25,
              "modules": {},
              "references": [],
            },
          ],
        },
      ],
      "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/lsp-analysis/test/test-case/module-imports/index.ts",
      "name": "app",
    },
  ],
}
`;

exports[`multiple files 1`] = `
{
  "errorCount": 0,
  "results": [
    {
      "entries": [
        {
          "method": "get",
          "path": "/",
          "sources": [
            {
              "character": 13,
              "content": "(c) => c.text("Hello, Hono!")",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/lsp-analysis/test/test-case/multiple/index.ts",
              "line": 4,
              "modules": {},
              "references": [],
            },
          ],
        },
      ],
      "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/lsp-analysis/test/test-case/multiple/index.ts",
      "name": "app",
    },
    {
      "entries": [
        {
          "method": "get",
          "path": "/",
          "sources": [
            {
              "character": 13,
              "content": "(c) => {
  return c.json({});
}",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/lsp-analysis/test/test-case/multiple/other.ts",
              "line": 2,
              "modules": {},
              "references": [],
            },
          ],
        },
        {
          "method": "post",
          "path": "/",
          "sources": [
            {
              "character": 14,
              "content": "(c) => c.json({ "hello": "world" })",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/lsp-analysis/test/test-case/multiple/other.ts",
              "line": 5,
              "modules": {},
              "references": [],
            },
          ],
        },
      ],
      "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/lsp-analysis/test/test-case/multiple/other.ts",
      "name": "app",
    },
  ],
}
`;

exports[`single file 1`] = `
{
  "errorCount": 0,
  "results": [
    {
      "entries": [
        {
          "method": "get",
          "path": "/",
          "sources": [
            {
              "character": 13,
              "content": "(c) => c.text("Hello, Hono!")",
              "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/lsp-analysis/test/test-case/single/index.ts",
              "line": 4,
              "modules": {},
              "references": [],
            },
          ],
        },
      ],
      "fileName": "/Users/jaccoflenter/dev/fiberplane/fpx/lsp-analysis/test/test-case/single/index.ts",
      "name": "app",
    },
  ],
}
`;
