use anyhow::Result;
use regex::Regex;
use schemars::schema::RootSchema;
use schemars::schema_for;
use schemars_zod::{convert, merge_schemas};
use std::fs::File;
use std::io::Write;
use std::path::Path;

#[derive(clap::Args, Debug)]
pub struct Args {
    #[arg(short, long, env, default_value = "packages/types")]
    pub project_directory: String,
    #[arg(short, long, env, default_value = "src/schemas.ts")]
    pub output_path: String,
}

pub async fn handle_command(args: Args) -> Result<()> {
    // Define which types should be used to generate schemas
    let schemas = Vec::from([
        schema_for!(fpx::api::models::ClientMessage),
        schema_for!(fpx::api::models::ServerMessage),
        schema_for!(fpx_app::state::AppState),
        schema_for!(fpx_app::models::workspace::OpenWorkspaceError),
        schema_for!(fpx_app::models::workspace::Workspace),
        schema_for!(fpx::config::FpxConfig),
        schema_for!(fpx::config::FpxConfigError),
    ]);

    let zod_schema = generate_zod_schemas(schemas)?;

    let file_path = Path::new(&args.project_directory).join(args.output_path.clone());
    let mut file = File::create(file_path.clone())?;
    file.write_all(&zod_schema)?;

    // Run formatter
    let output = std::process::Command::new("npx")
        .args([
            "@biomejs/biome",
            "format",
            "--write",
            args.output_path.as_str(),
        ])
        .current_dir(args.project_directory)
        .output()?;

    if !output.status.success() {
        eprintln!(
            "Failed to run Biome: {}",
            String::from_utf8_lossy(&output.stderr)
        );

        anyhow::bail!("Command failed")
    }

    println!(
        "Succesfully generated schemas at:\n{}",
        file_path.to_str().unwrap()
    );

    Ok(())
}

fn generate_zod_schemas(schemas: Vec<RootSchema>) -> Result<Vec<u8>> {
    println!("Generating Zod schemas and infered types:");

    let merged = merge_schemas(schemas.into_iter());
    let converted = convert(merged);

    let mut output = String::new();

    output.push_str(
        r#"
// =========================================== //
// DO NOT MAKE MANUAL CHANGES TO THIS FILE     //
// This file is automatically generated.       //
//                                             //
// To regenerate, run `pnpm build:types`       //
// from the root repository of the repository. //
// =========================================== //

import { z } from "zod";

// TODO: Polyfill memoizeOne for now, seems like this breaks our TypeScript setup
// See: https://github.com/alexreardon/memoize-one/issues/267
// Couldn't get it to work reliably on both the CI and locally with custom module type definitions
function memoizeOne<T>(schema: T) {
  return schema;
}
    "#,
    );

    for (name, schema) in converted.into_iter() {
        let schema = rename_schema_identifier(&name, &schema);

        // Add whitespace between schema and inferred type
        let schema = schema.replace("\n", "\n\n");

        output.push_str(&format!("\n{}", schema));

        println!("âœ“ {}", name);
    }

    Ok(output.as_bytes().to_owned())
}

/// Appends `Schema` to the schema identifier to match our code style
fn rename_schema_identifier(name: &str, schema: &str) -> String {
    let schema = schema
        .replace(
            &format!("const {} =", name),
            &format!("const {}Schema =", name),
        )
        .replace(
            &format!("typeof {}", name),
            &format!("typeof {}Schema", name),
        )
        .split("\n")
        .collect::<Vec<&str>>()
        .join("\n\n");

    append_schema_to_lazy_references(&schema)
}

/// Append `Schema` to the lazy Zod references to match our code style
fn append_schema_to_lazy_references(input: &str) -> String {
    let regex = Regex::new(r"(z\.lazy\()([A-Za-z0-9_]+)(\))").unwrap();

    regex
        .replace_all(input, |captures: &regex::Captures| {
            format!("{}{}Schema{}", &captures[1], &captures[2], &captures[3])
        })
        .to_string()
}
